import 'package:app_ui_kit/all_file/app_ui_kit_all_file.dart';import 'package:hlshop/all_file/all_file.dart';import 'package:hlshop/core/utils/image_utils.dart';part 'rating_state.dart';part 'rating_cubit.freezed.dart';const ratingComment = 'RatingComment';class RatingCubit extends Cubit<RatingState> {  RatingCubit({    required this.orderDataEntity,    required this.orderProductList,  }) : super(          const RatingState(),        ) {    mapImages = Map.fromEntries(      orderDataEntity.orderProductList.mapAsList(        (e) => MapEntry(e.orderItemID ?? '', []),      ),    );    form = FormGroup(      {        ratingComment: FormArray<String>(          orderDataEntity.orderProductList.mapAsList(            (e) => FormControl<String>(              value: '',              validators: [                Validators.maxLength(50),              ],            ),          ),        ),      },    );    mapRating = Map.fromEntries(      orderDataEntity.orderProductList.mapAsList(        (e) => MapEntry(e.orderItemID ?? '', 5),      ),    );  }  late final Map<String, double> mapRating;  late final RatingRepo _repo = getIt();  final OrderDataEntity orderDataEntity;  final List<OrderProductEntity> orderProductList;  late final FormGroup form;  late Map<String, List<ImageEntity>> mapImages;  FutureOr<void> uploadImage(      {required BuildContext context, required String keyMap}) async {    try {      emit(        state.copyWith(          uploadImageStatus: state.uploadImageStatus.toPending(),        ),      );      final pickedFile = await ImageUtils.getImageFromLibrary(        ImagePicker(),        context,      );      final newMedias = [...mapImages[keyMap] ?? <ImageEntity>[]];      log('newMedias: $newMedias');      if (pickedFile != null && context.mounted) {        final media = await _repo.uploadImage(file: File(pickedFile.path));        newMedias.add(media);      }      mapImages.forEach((key, value) {        if (key == keyMap) {          mapImages[key] = newMedias;        }      });      emit(        state.copyWith(          uploadImageStatus: const ApiStatus.done(),        ),      );    } catch (e) {      emit(        state.copyWith(          uploadImageStatus: ApiStatus.error(e),        ),      );    }  }  FutureOr<void> deleteImage({required String src, required String keyMap}) {    emit(      state.copyWith(        uploadImageStatus: state.uploadImageStatus.toPending(),      ),    );    final newMedias = <ImageEntity>[...mapImages[keyMap] ?? <ImageEntity>[]]      ..removeWhere((media) {        return media.src == src;      });    mapImages.forEach((key, value) {      if (key == keyMap) {        mapImages[key] = newMedias;      }    });    emit(      state.copyWith(        uploadImageStatus: const ApiStatus.done(),      ),    );  }  FutureOr<void> submit() async {    log('sellerService: ${state.providerServiceRating.toInt()}');    log('deliveryService: ${state.deliveryServiceRating.toInt()}');    log('driverService: ${state.shipperServiceRating.toInt()}');    final req = RatingOrderReqEntity(      orderID: orderDataEntity.id ?? '',      orderItemEntity: orderDataEntity.orderProductList.mapAsList(        (item) => OrderItemEntity(          id: item.orderItemID,          detailRating: DetailRating(            productQuality: (mapRating[item.orderItemID] ?? 0).toInt(),            sellerService: state.providerServiceRating.toInt(),            deliveryService: state.deliveryServiceRating.toInt(),            driverService: state.shipperServiceRating.toInt(),          ),          comment: form                  .getArray<String>(ratingComment)                  ?.value                  .getOrNull(orderProductList.indexOf(item)) ??              '',          images: mapImages[item.orderItemID] ?? [],        ),      ),    );    try {      emit(state.copyWith(status: state.status.toPending()));      await _repo.create(ratingOrderReqEntity: req);      emit(state.copyWith(status: const ApiStatus.done()));    } catch (e) {      emit(state.copyWith(status: ApiStatus.error(e)));    }  }  FutureOr<void> updateRating({String orderItemID = '', double rating = 0}) {    mapRating[orderItemID] = rating;  }  FutureOr<void> updateProviderRating(double rating) {    emit(state.copyWith(providerServiceRating: rating));  }  FutureOr<void> updateDeliverRating(double rating) {    emit(state.copyWith(deliveryServiceRating: rating));  }  FutureOr<void> updateShipperRating(double rating) {    emit(state.copyWith(shipperServiceRating: rating));  }  double ratingValue(String orderItemID) {    return mapRating[orderItemID] ?? 0;  }  List<ImageEntity> getMedias(String orderItemID) =>      mapImages[orderItemID] ?? [];}